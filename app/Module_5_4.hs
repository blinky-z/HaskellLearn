module Module_5_4 where

import           Prelude   hiding (Just, Maybe, Nothing)

-- Maybe и [] - это тоже Монады
data Maybe a = Nothing | Just a
  deriving (Eq, Ord)

{-
class Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  fail :: String -> m a
-}


-- реализуем инстанс Монады для Maybe:

instance Functor Maybe where

instance Applicative Maybe where

instance Monad Maybe where
  return x = Just x
  (Just x) >>= k = k x
  Nothing >>= _ = Nothing

  (Just _) >> m = m
  Nothing >> _ = Nothing

  fail _ = Nothing

-- имея Монады, можно строить императивный код с использованием do-нотации:
-- правила трансляции do-нотации:
{-
-- если у нас есть просто две инструкции идущие по порядку, то это можно представить так:
-- мы от значения a, упакованного в первую монаду, переходим просто ко второй монаде,
-- таким образом строится цепочка вычислений
-- важно понимать, что мы все еще можем использовать значение e1 в этой цепочке, так как область видимости цепочки - вся цепочка
-- таким образом строится будто императивный код внутри одного блока, видимость которого - весь блок
do { e1; e2 } = e1 >> e2

-- p <- e1 можно понимать как присвоение значения переменной, а далее идет еще одна какая-то иструкция
-- разберем генерирующийся на самом деле код e1 >>= (\p -> e2):
-- делается следующее:
-- мы распаковываем контейнер e1, доставая оттуда значение, только теперь это значение мы можем использовать в следующем
-- вычислении (\p -> e2), то есть значение выражения e1 связывается с переменной p
-- важно снова думать об этой конструкции как о цепочке вычислений, теперь в нашей области видимости появилось значение,
-- которое было упаковано в монаду e1
-- еще важно, что e2 - может быть любой инструкцией, будь то присваивание или обычная инструкция
do { p <- e1; e2 } = e1 >>= \p -> e2

-- еще важно то, что из того, что в лямбда функции мы можем делать pattern matching, например тут:
-- (\p -> e2) мы могли бы писать так: (\(Just x) -> e2)
-- тогда, если сопоставление с образцом происходит неудачно, вызывается автоматически функция fail, и если используется ее
-- стандартное определение, то программа упадет из-за функции error
-- но ведь такая конструкция внутри do p <- e1 транслируется в лямбда функцию, то и в do нотации мы можем использовать
-- pattern matching

-- данная конструкция позволяет выполнить немонодическое вычисление e1 и связать значение этого вычисления с переменной v,
-- и после этого использовать это значение v в следующей инструкции e2
-- то есть, это отличается от второй конструкции тем, что выше происходит присваивание внутри монодического вычисления
-- а здесь, не внутри монодического вычисления

-- например:
-- let y = 3 <- немонодическое вычисление, возможно писать такой код внутри do
-- y <- 3 <- 3 - не монада! мы не можем связать значение вычисления 3 с y
do { let v = e1; e2 } = let v = e1 in do e2
-}

-- например, напишем такой код:
-- Identity из модуля 5.3
newtype Identity a = Identity { runIdentity :: a }
  deriving (Show, Eq)

instance Functor Identity where
  fmap f (Identity x) = Identity (f x)

instance Applicative Identity where
  pure x = Identity x
  Identity f <*> Identity v = Identity (f v)

instance Monad Identity where
  return x = Identity x
  Identity x >>= f = f x

wrap'n'succ :: Enum a => a -> Identity a
wrap'n'succ x = return (succ x)

-- в данном коде мы построили цепочку вычислений
-- вычисляется монада
-- 1. вычисляется выражение wrap'n'succ i
-- мы связываем её значение с переменной x
-- 2. вычисляется выражение wrap'n'succ x
-- мы связываем её значение с переменной y
-- 3. возвращаем вычисленные значения i и x + y
-- выражение слева от >>= должно быть обязательно монадой, чтобы мы могли связывать ее значение с помощью оператора (>>=)
goWrap =
  let i = 3 in
  wrap'n'succ i >>= \x ->
  wrap'n'succ x >>= \y ->
  wrap'n'succ y >> {-<- эта строчка может быть закомментирована-}
  return (i, x + y) {-<- тип возвращаемого значения - Монада-}

-- runIdentity goWrap
--  -> (3,9)

-- все то же самое может быть написано проще в do-нотации:
goWrap' = do
  let i = 3
  x <- wrap'n'succ i
  y <- wrap'n'succ x
  wrap'n'succ y
  return (i, x + y)

-- здесь роль точки с запятой (;) играет отступ
-- однако, ничего не мешает писать так: let i = 3;x <- wrap'n'succ i;y <- wrap'n'succ x;wrap'n'succ y;return (i, x + y)
-- мы получили полноценную императивную программу
--
-- производить все вычисления мы должны только в рамках одной монады
-- значение внутри самой монады не важно

-- можно спросить тип монодического вычисления goWrap:
-- :t goWrap'
--  -> goWrap' :: Identity (Integer, Integer)
