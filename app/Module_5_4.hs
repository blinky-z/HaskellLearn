module Module_5_4 where

import           Prelude hiding (Just, Maybe, Nothing)

--
-- -----------------------
-- 5.4 Список и Maybe как монады
-- -----------------------
--

-- Maybe и [] - это тоже Монады
data Maybe a = Nothing | Just a
  deriving (Eq, Ord)

{-
class Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  fail :: String -> m a
-}


-- реализуем инстанс Монады для Maybe:

instance Functor Maybe where

instance Applicative Maybe where

instance Monad Maybe where
  return x = Just x
  (Just x) >>= k = k x
  Nothing >>= _ = Nothing

  (Just _) >> m = m
  Nothing >> _ = Nothing

  fail _ = Nothing

-- имея Монады, можно строить императивный код с использованием do-нотации:
-- правила трансляции do-нотации:
{-
-- если у нас есть просто две инструкции идущие по порядку, то это можно представить так:
-- мы от значения a, упакованного в первую монаду, переходим просто ко второй монаде,
-- таким образом строится цепочка вычислений
-- важно понимать, что мы все еще можем использовать значение e1 в этой цепочке, так как область видимости цепочки - вся цепочка
-- таким образом строится будто императивный код внутри одного блока, видимость которого - весь блок
do { e1; e2 } = e1 >> e2

-- p <- e1 можно понимать как присвоение значения переменной, а далее идет еще одна какая-то иструкция
-- разберем генерирующийся на самом деле код e1 >>= (\p -> e2):
-- делается следующее:
-- мы распаковываем контейнер e1, доставая оттуда значение, только теперь это значение мы можем использовать в следующем
-- вычислении (\p -> e2), то есть значение выражения e1 связывается с переменной p
-- важно снова думать об этой конструкции как о цепочке вычислений, теперь в нашей области видимости появилось значение,
-- которое было упаковано в монаду e1
-- еще важно, что e2 - может быть любой инструкцией, будь то присваивание или обычная инструкция
do { p <- e1; e2 } = e1 >>= \p -> e2

-- еще важно то, что из того, что в лямбда функции мы можем делать pattern matching, например тут:
-- (\p -> e2) мы могли бы писать так: (\(Just x) -> e2)
-- тогда, если сопоставление с образцом происходит неудачно, вызывается автоматически функция fail, и если используется ее
-- стандартное определение, то программа упадет из-за функции error
-- но ведь такая конструкция внутри do p <- e1 транслируется в лямбда функцию, то и в do нотации мы можем использовать
-- pattern matching

-- данная конструкция позволяет выполнить немонодическое вычисление e1 и связать значение этого вычисления с переменной v,
-- и после этого использовать это значение v в следующей инструкции e2
-- то есть, это отличается от второй конструкции тем, что выше происходит присваивание внутри монодического вычисления
-- а здесь, не внутри монодического вычисления

-- например:
-- let y = 3 <- немонодическое вычисление, возможно писать такой код внутри do
-- y <- 3 <- 3 - не монада! мы не можем связать значение вычисления 3 с y
do { let v = e1; e2 } = let v = e1 in do e2
-}

-- например, напишем такой код:
-- Identity из модуля 5.3
newtype Identity a = Identity { runIdentity :: a }
  deriving (Show, Eq)

instance Functor Identity where
  fmap f (Identity x) = Identity (f x)

instance Applicative Identity where
  pure x = Identity x
  Identity f <*> Identity v = Identity (f v)

instance Monad Identity where
  return x = Identity x
  Identity x >>= f = f x

wrap'n'succ :: Enum a => a -> Identity a
wrap'n'succ x = return (succ x)

-- в данном коде мы построили цепочку вычислений
-- вычисляется монада
-- 1. вычисляется выражение wrap'n'succ i
-- мы связываем её значение с переменной x
-- 2. вычисляется выражение wrap'n'succ x
-- мы связываем её значение с переменной y
-- 3. возвращаем вычисленные значения i и x + y
-- выражение слева от >>= должно быть обязательно монадой, чтобы мы могли связывать ее значение с помощью оператора (>>=)
goWrap =
  let i = 3 in
  wrap'n'succ i >>= \x ->
  wrap'n'succ x >>= \y ->
  wrap'n'succ y >> {-<- эта строчка может быть закомментирована-}
  return (i, x + y) {-<- тип возвращаемого значения - Монада-}

-- runIdentity goWrap
--  -> (3,9)

-- все то же самое может быть написано проще в do-нотации:
goWrap' = do
  let i = 3
  x <- wrap'n'succ i
  y <- wrap'n'succ x
  wrap'n'succ y
  return (i, x + y)

-- здесь роль точки с запятой (;) играет отступ
-- однако, ничего не мешает писать так: let i = 3;x <- wrap'n'succ i;y <- wrap'n'succ x;wrap'n'succ y;return (i, x + y)
-- мы получили полноценную императивную программу
--
-- производить все вычисления мы должны только в рамках одной монады
-- значение внутри самой монады не важно

-- можно спросить тип монодического вычисления goWrap:
-- :t goWrap'
--  -> goWrap' :: Identity (Integer, Integer)


--
-- Монада списка
--
-- реализация инстанса Монады для списков:
{-
instance Monad [] where
  return x = [x]
  xs >>= k = concat (map k xs)
  fail _ = []
-}

-- самое интересное здесь - реализация оператора (>>=)
-- нам требуется применить стрелку Клейсли для элемента внутри Монады
-- но так как элементов внутри монады много, то мы должны применить стрелку Клейсли к каждому элементу с помощью функции map
-- но так как map k даст нам список списков (так как стрелка Клейсли порождает монаду: a -> m a), а значит для каждого элемента
-- порождается список, то нам нужно собрать список с помощью функции concat
-- [1,2,3] >>= (\x -> [x + 1])
--  -> [2,3,4]

-- и что еще более интересно, list comprehension реализован именно через do код:
list = [(x,y) | x <- [1,2,3], y <- [4,5,6]]

list' = do
  x <- [1,2,3]
  y <- [4,5,6]
  return (x,y)

-- то же самое, но не в do-нотации:
list'' =
  [1,2,3] >>= (\x ->
  [4,5,6] >>= (\y ->
  return (x,y)))

-- работа такова:
-- сначала достается каждый элемент из первого, и с помощью map к нему применяется функция
{-(\x -> [4,5,6] >>= (\y -> return (x,y)))-}
-- то же самое происходит и со вторым списком, при этом x, элемент первого списка, находится в области видимости
-- берется элемент из второго списка и к нему применяется функция
{-(\y -> return (x,y))-}
-- и так генерируются все возможные пары

-- пример работы
-- как преобразовывается выражение [1,2] >>= (\x -> [3,4] >>= (\y -> return (x,y))):
--
-- concat (map (\x -> [3,4] >>= (\y -> return (x,y))) [1,2])
-- и получаются 2 цепочки вычислений из вызова map:
-- -> (\1 -> [3,4] >>= (\y -> return (1,y))) : (\2 -> [3,4] >>= (\y -> return (2,y))) : []
-- -> ([3,4] >>= (\y -> return (1,y)) : ([3,4] >>= (\y -> return (2,y)) : []
-- -> (concat (map (\y -> return (1,y)) [3,4])) : (concat (map (\y -> return (2,y)) [3,4]) : []
-- -> (concat [[(1,3)], [(1,4)]]) : (concat [[(2,3)], [(2,4)]]) : []
-- -> [[(1,3),(1,4)],[(2,3),(2,4)]]
-- теперь добавим еще concat, который мы опустили:
-- [(1,3),(1,4),(2,3),(2,4)]

--
-- мы можем делать ветвления if в цепочке вычислений:
lst = do
  x <- [1,2,3]
  y <- [1,2]
  True <- return (x /= y)
  return (x, y)

-- True <- return (x /= y) позволяет прервать вычисления, и (x, y) текущего разветвления программы не будет добавлен
-- в результат
-- так как если (x /= y) = False, то сопоставление с образцом (True) произойдет неудачно, и вычисление цепочки прервется

-- также возможно писать такой код, и результат будет эквивалентен:
lst' = do
  x <- [1,2,3]
  y <- [1,2]
  if x /= y then "Z" else []
  return (x, y)

-- почему это работает можно легко понять, транслировав это в следующее:
-- [1,2,3] >>= (\x -> [1,2] >>= (\y -> (if x /= y then "Z" else []) >> return (x, y)))
-- дело в том, что по правилам трансляции (>>) и (>>=) пустой список слева прерыванит цепочку вычислений:
-- xs >>= k = concat (map k xs) - применение операций к пустому списку дает пустой список
-- иначе же операция return (x, y) примененная к "Z" даст как раз то, что нам нужно
-- но важно писать именно "Z" или любой одноэлементынй список, иначе операция return (x, y) будет применена 2 раза к каждому
-- элементу и мы получим список из повторяющихся 2 раза пар