module Module_5_3 where

--
-- -----------------------
-- 5.3 Монада Identity
-- -----------------------
--

-- Identity - контейнер, который упаковывает любой базовый тип, не прибавляя никаких других свойств значению
-- Identity есть и в стандартной библиотеке, но тут как обычно мы напишем реализацию сами
newtype Identity a = Identity { runIdentity :: a }
  deriving (Show, Eq)

{-
class Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
-}

instance Functor Identity where
  fmap f (Identity x) = Identity (f x)
﻿
instance Applicative Identity where
  pure x = Identity x
  Identity f <*> Identity v = Identity (f v)

instance Monad Identity where
  return x = Identity x {-упаковываем передаваемое значение в контейнер-}
  Identity x >>= f = f x {-достаем значение из передаваемого контейнера и передаем это значение в стрелку Клейсли f-}


-- Для того, чтобы монады работали правильно, требуется соблюдать следующие законы:
-- 1. return a >>= f = f a
-- данный закон говорит что упаковывания первоначального значчения в контейнер, а потом передача данного контейнера в
-- оператор (>>=) и получение обновленного контейнера должно быть эквивалентно простому вызову стрелки Клейсли,
-- которая по первоначальному значению строила ообновленный контейнер
-- 2. m >>= return = m
-- данный закон говорит, что применение оператора (>>=) к контейнеру и передача как стрелки Клейсли функции return должно
-- быть эквивалентно самому контейнеру
-- то есть, тут просто достается значение из контейнера и обратно упаковывается в него
-- данный закон гарантирует то, что при применении оператора (>>=) старый контекст сохранится
-- например, так мы реализовали оператор (>>=) для записей лога:
{-
bindLog :: Log a -> (a -> Log b) -> Log b
bindLog (Log xs x) f =
  let (Log ys y) = f x
  in Log (xs ++ ys) y
-}
-- мы сохраняли старые записи, хоть и работа функции над значением, упакованным в контейнер, возвращало контейнер только
-- с комментирвоанием текущего действия, но старые действия теряться не должны