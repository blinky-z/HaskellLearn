module Module_5_8 where

import           Control.Monad
import           Module_5_7

--
-- -----------------------
-- 5.8 Монада State
-- -----------------------
--

-- Монада State обладает следующим эффектом:
-- возможность работы с изменяемым состояние
-- то есть, помимо монодического вычисления еще конструируется некоторое состояние определенного типа, к которому мы можем
-- обращаться, записывая туда значение и считывая оттуда значение в процессе вычисления

-- Монада State - это объединение двух идей: Reader и State
-- Reader могла считывать какие-то значения из внешего окружения
-- Writer могла писать писать сообщения в лог
-- Монада State же теперь может и считывать, и записывать куда-то

-- тип хранилища, в которое мы пишем и из которого мы читаем, долежн быть одинаковым
-- s - тип состояния
-- a - тип значения, хранящегося в контейнере
newtype State s a = State { runState :: s -> (a, s) }

-- runState :: State s a -> s -> (a, s)
-- runState позволяет доставать состояние и значение из какого-то внешего окружения
-- первый параметр - это сама монада State
-- более интересен же второй параметр - s. Это инициализирующее значение для нашего состояния
-- возвращается же пользователю значение, которое хранится в Монаде, и новое состояние, которое получилось
-- после операций чтения/записи в переданную монаду

instance Functor (State s) where

instance Applicative (State s) where

instance Monad (State s) where
-- здесь мы делаем следующее:
-- так как нам нужно построить контейнер, который принимает какое-то инициализирующее значение, а возвращает пару
-- (значение, состояние),
-- то мы пишем лямбда функцию, которая принимает это состояние, а возвращает пару (значение, состояние)
  return a = State $ \st -> (a, st)

-- что делает bind:
-- 1. достает значение из монады State
-- достать значение можно с помощью сопоставления с образцом:
-- let (a, st') = runState m st <- передаем в runState монаду, из которой надо достать значение, и запрашиваемое
-- инициализирущее состояние (в котором можно писать и читать во время вычисления)
-- и получаем пару (значение, новое состояние)
-- 2. обрабатывает значение с помощью стрелки Клейсли:
-- m' = k a <- получается новая монада State
-- 3. запускаем итоговое вычисление, на новой монаде и новом состоянии: runState m' st'
-- так как оператор (>>=) связывает 2 вычисления
-- 4. упаковываем результат вычисления: State $ (\st -> (runState m' st'))
  m >>= k = State $ \st ->
    let (a, st') = runState m st
        m' = k a
    in runState m' st'

-- что такое вообще инициализирующее состояние?
-- инициализирующее состояние - это как раз то состояние, в котором мы можем писать и читать во время вычисления, а после
-- вычисления возвращается новое состояние, с уже внесенными туда изменениями

--
-- существуют вспомогательные функции для работы с состоянием:

-- данная функция возвращает только новое состояние
execState :: State s a -> s -> s
execState m s = snd (runState m s)

-- данная функция возвращает только новое значение
evalState :: State s a -> s -> a
evalState m s = fst (runState m s)

-- следующие функции очень похожи на функции ask из монады Reader и tell из Монады Writer
-- данная функция позволяет получить состояние как объект типа State (ask тоже могла получить внешюю среду)
-- данная функция позволяет работать с состоянием как с текущем инструкцией в монодических вычислениях,
-- ведь напрямую мы с данными не работает, а только через монады
get :: State s s
get = State $ \st -> (st, st)

-- использование:
-- runState get 5
--  -> (5,5) <- значение 5, и состояние тоже 5

-- put позволяет поместить состояние в монаду State, но не устанавливает значение
-- а старое значение как бы уничтожается, в цепочке монадических вычислений, если монада будет пропущена через
-- эту функцию, то значение потеряется
put :: s -> State s ()
put st = State $ \_ -> ((), st)

-- использование:
-- runState (put 7) 5
--  -> ((),7)

-- данная функция увеличивает состояние на единицу, а возвращает предыдуще значение в этом состоянии
-- все вызовы здесь, как и в Reader будут неяно работать с состоянием, то есть неявно ко все функциям применяется состояние
-- так как чтобы запустить вычисление функции runState, необходимо передать ей монаду и инициализирующее состояние, в рамках
-- которого будут идти вычисления
-- использование:
-- runState tick 5
--  -> (5,6)
tick :: State Int Int
tick = do
  n <- get {-в переменную n достается значение из контейнера State s s-}
  put (n + 1)
  return n

-- ВАЖНО!!
-- конструкция (put (n + 1) >> return n) складывается в одну из-за поведения оператора bind (>>=):
-- он берет монаду слева, выполняет ее, обрабатывает значение монады слева Стрелкой Клейсли, и складывает эффекты
-- работы двух вычислений
-- и просто возвращается (n, n + 1))
-- на этом примере можно видеть, почему нам нужно третье вычисление runState m' st', чтобы эффекты сохранялись, потому что
-- у нас ЦЕПОЧКА ВЫЧИСЛЕНИЙ, а цепочка вычислений всегда ведет к какому-то конечному результату, поэтому оператор
-- bind (>>=) скалывает два вычисления в одно
-- например, вспомним пример с Log, там мы добавляли сообщения из старой монады, и сообщения из новой монады, но ведь это и
-- есть поведение оператора (>>=):
-- вычислить монаду слева (достать значение из нее), обработать значение монады и построить новую монаду, и сложить эффекты
-- вычислений старой монады и новой монады
-- так и в Log тоже: вычислялась монада слева (доставались значения из нее, но чтобы достать из нее что-то, надо ее вычислить),
-- обрабатывалось значение и порождались новые сообщения, и 3 вычисление было - сложить эффекты монад, то есть сложить
-- старые сообщения и новые, а также сохранить новый результат
--


-- tick можно переписать следующим образом:
tick' = get >>= (\n -> put(n + 1) >> return n)

-- данная функция модифицирует состояние
-- первый параметр - это функция, которая изменяет состояние
modify :: (s -> s) -> State s ()
modify f = State $ \s -> ((), f s)

-- modify можно переписать в таком виде, потому что put изменяет состояние
modify' f = do
  s <- get
  put $ f s

-- использование:
-- runState (modify (^2)) 5
--  -> ((),25)
-- runState (modify' (^2)) 5
--  -> ((),25)

-- проверка изменения состояния
changeState = do
  n1 <- get {-считали состояние n-}
  put (n1 + 1) {-изменили состояние до n + 1-}
  n2 <- get {-считали состояние (n + 1)-}
  put (n2 + 1) {-изменили состояние до (n + 2)-}
  return n1 {-возвращаем начальное состояние, и конечное. Начальное - n, конечное - (n + 2)-}
--  в резульате эффекты команд put (n2 + 1) >> return n1 объединяются, и результат становится равным (n, (n+2))
-- запустим:
-- runState changeState 5
--  -> (5,7)
-- состояние действительно изменяется



--
-- https://stepik.org/lesson/8444/step/6?unit=1579
-- поднятие вычисления с Reader до State
{-
readerToState :: Reader r a -> State r a
readerToState m = do
  st <- get
  return (runReader m st)
-}

--
--

writerToState :: Monoid w => Writer w a -> State w a
writerToState m = do
  st <- get
  (val, messages) <- return $ runWriter m
  put (st `mappend` messages)
  return val

-- попробуем попрограммировать в монаде State:
-- функция succ будет возвращать увеличенное на 1 значение, т.е. измененное состояние функции tick, а значит требуется
-- вызывать функцию execState для того, чтобы достать состояние
succ' :: Int -> Int
succ' n = execState tick n

-- функция сложения
-- replicate n tick порождает список из n монад tick
-- sequence запускает вычисление этих монад
-- в итоге, значение x будет увеличено n раз, что и явлляется сложением
plus :: Int -> Int -> Int
plus n x = execState (sequence_ $ replicate n tick) x

-- использование:
-- 4 `plus` 15
--  -> 19

--
-- https://stepik.org/lesson/8444/step/9?unit=1579
fibStep :: State (Integer, Integer) ()
fibStep = do
  (a, b) <- get
  put (b, a + b)

execStateN :: Int -> State s a -> s -> s
execStateN n m x = execState (replicateM_ n m) x

fib :: Int -> Integer
fib n = fst $ execStateN n fibStep (0, 1)

--
-- https://stepik.org/lesson/8444/step/10?unit=1579
data Tree a = Leaf a | Fork (Tree a) a (Tree a) deriving Show

numberTree :: Tree () -> Tree Integer
numberTree tree = evalState helper (tree, 1)
  where
    helper :: State (Tree (), Integer) (Tree Integer)
    helper = do
      (t, n) <- get
      case t of
        Leaf ()    -> do
          put (t, n + 1)
          return $ Leaf n
        Fork l _ r -> do
          put (l, n)
          l1 <- helper
          (_, middleN) <- get
          put (r, middleN + 1)
          r1 <- helper
          return $ Fork l1 middleN r1

-- numberTree (Fork (Fork (Leaf ()) () (Leaf ())) () (Fork (Leaf ()) () (Leaf ())))
