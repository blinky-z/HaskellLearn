module Module_5_3_tasks where

--
-- https://stepik.org/lesson/8438/step/3?unit=1573
-- Если некоторый тип является представителем класса
-- Monad
-- , то его можно сделать представителем класса
-- Functor
-- , используя функцию
-- return
-- и оператор
-- >>=
-- . Причём, это можно сделать даже не зная, как данный тип устроен.
--
-- Пусть вам дан тип
-- data SomeType a = ...
-- и он является представителем класса Monad. Сделайте его представителем класса Functor.
--instance Functor SomeType where
--    fmap f x = x >>= (\val -> return $ f val)
-- мне нужно протащить функцию f наверх, к значению, упакованному в контейнер SomeType, этот контейнер здесь - это x
{-
class Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
-}
-- если наш тип SomeType является представителем тайпкласса Monad, то это значит, что мы можем делать следующее:
-- 1) упаковывать значение в контейнер
-- 2) менять значение, уже упакованного в контейнер
-- при чем все это мы можем делать, не зная как реализован этот инстанс

-- pattern matching мы сделать не сможем, так как мы даже не знаем констрктор данных у типа SomeType,
-- соотвественно достать значение из контейнера x тоже

-- но зато доставать значение из контейнера x умеет оператор (>>=)
-- тогда мы просто напишем для этого лямбда функцию, которая будет принимать значение и строить новый контейнер:
-- (\val -> return $ f val)
-- и тогда можно легко вызвать оператор (>>=), передавая туда изначальный контейнер и функцию для обработки
-- завернутого значения
