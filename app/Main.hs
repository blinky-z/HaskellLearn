module Main where

import Lib

-- определение своих операторов
infixl 6 *+*

a *+* b = a^2 + b^2 {-оператор определен в инфиксном виде-}
--(*+*) a b = a^2 + b^2 {-определение в префиксном виде, т.е. функциональном-}
--Использование:
s1 = 3 *+* 5 {-инфиксное использование-}
s2 = (*+*) 3 5 {-префиксное-}

--
--приоритет и ассоциативность операторов
--(++) [1,2] 3 : [4,5,6] {-такое работать не будет, потому что приоритет функций равен 10, а вызов функций левоассоциативен
-- функция ожидает 2 списка, первое что она видит - [1,2], удовлетворяет, а вот аргумент 3 не удовлетворяет, и вообще
-- тут 4 аргумента-}
-- еще один пример: (++) [1,2] (:) 3 [4,5,6] - здесь снова вызов (++) видит [1,2] и далее оператор (:), который не подходит
-- исправить первое можно так: (++) [1,2] (3 : [4,5,6])
-- или так: (++) [1,2] $ 3 : [4,5,6]
-- а второе так: (++) [1,2] ((:) 3 [4,5,6])
-- или так: (++) [1,2] $ (:) 3 [4,5,6]
-- а вот если не применять оператор (++) в префиксном стиле, то такое сработает:
-- [1,2] ++ 3 : [4,5,6] {-оба операторы правоассоциативны и имеют одинаковый приоритет, сначала будет вычислено 3 : [4,5,6]
-- и выражение превратится в такое: [1,2] ++ [3,4,5,6]-}
-- также будет работать и такое:
-- [1,2] ++ (:) 3 [4,5,6] - здесь оператор ++ вызван в инфиксном стиле, а определение оператора (++) такое:
-- :i (++)
--infixr 5 ++
-- т.е. сначала вычисление аргументов происхоидт справа: сначала (:) 3 [4,5,6] превращается в [3,4,5,6] и списки успешно
-- складываются
--

-- двойной факториал
doubleFact :: Integer -> Integer
doubleFact 2 = 2
doubleFact 1 = 1
doubleFact n = n * doubleFact (n - 2)
--
-- фибоначчи
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci (-1) = 1
fibonacci n | n > 0 = fibonacci (n - 1) + fibonacci (n - 2)
            | n < 0 = fibonacci (n + 2) - fibonacci (n + 1)
--
-- факториал через использование цикла использование дополнительной переменной, накапливающей текущее состояние факториала
-- на самом деле используется дополнительная функция, и ее аргумент хранит текущее состояние факториала
factorial2 n | n >= 0 = factorial2Helper 1 n
             | otherwise = error "asg must be >= 0"

factorial2Helper acc 0 = acc
factorial2Helper acc n = factorial2Helper (acc * n) (n - 1)
-- факториал через вызов самого себя
factorial 0 = 1
factorial n = n * factorial (n - 1)
-- определение через аккумулятор - эффективнее. Оптимизации компилятора оптимизурующие рекурсию таким образом называются
-- Tail Call Optimization
--
-- фибоначчи через функцию хелпер
fibonacci2 n | n > 0 = fibonacci2 (n - 1) + fibonacci2 (n - 2)
             | n < 0 = fibonacci2 (n + 2) - fibonacci2 (n + 1)

fibonacci2Helper acc 0 = acc
fibonacci2Helper acc n = fibonacci2Helper acc (n - 1)
--

main :: IO ()
main = print (factorial (35))