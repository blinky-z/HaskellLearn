module Module_5_1 where

import           Prelude hiding (Functor, fmap)

-- Теория

--
-- -----------------------
-- 5.1 Класс типов Functor и законы для него
-- -----------------------
--

-- Обычно мы работали с базовыми типами или однопараметречискими типами - как Maybe a, [a], и прочие завернутые в контейнер з
-- значения
-- однопараметрические типы - это функции над базовыми типами
-- однако, даже для таких функций над типами мы можем задавать общий интерфейс, и работать с конструкторами типов
-- с помощью общего интерфейса
-- то есть они обобщают идею "контейнерных типов"

-- первый пример - Functor
class Functor f where
  fmap :: (a -> b) -> f a -> f b
-- здесь f - это конструктор типа, который принимает один параметр и возвращает какой-то другой тип
-- то есть :k f - это * -> *
-- поэтому мы можем применять конструктор типа f к другим типам a и b
-- так Functor и определен в стандартной библиотеке:
-- class Prelude.Functor (f :: * -> *)

-- функция fmap
-- fmap первый параметром принимает произвольную функцию типа (a -> b),
-- вторым параметром принимает какой-то контейнерный тип (f a),
-- например, Maybe Int, [Int]
-- и на выходе данная функция возвращает значение типа a, упакованное в тот же контейнер f
-- то есть, пришло (Int -> String) -> Maybe Int - вернулось Maybe String

-- напишем представителя тайпкласса Functor для списков:
{-
instance Functor [] where
  fmap = map
-}
-- и можно использовать так:
-- fmap (^2) [1,2,3]
--  -> [1,4,9]

-- вообще, как можно думать о Functor
-- Functor позволяет поднять вычисление с уровня базовых типов a и b до уровня работы над контейнерами:
-- fmap :: (a -> b) -> (f a -> f b)
-- fmap принимает какую-то функцию для работы над элементами контейнера, и возвращает функцию, которая уже работает
-- непосредественно с самими контейнерами: (f a -> f b)

-- напишем представителя тайпкласса Functor для Maybe:
instance Functor Maybe where
  fmap _ Nothing  = Nothing
  fmap f (Just a) = Just (f a)

-- здесь логика такая:
-- 1. независимо от того, какая функция применяется к элементу, упакованному в контейнер, если там лежит Nothing (а Nothing
-- представляет собой контейнер, в котором ничего не лежит), то и прмиенять функцию не к чему, и в контейнере также останется
-- Nothing
-- 2. Если же в контейнере есть элемент, то мы просто применяем функцию f к внутренним данным в контейнере, и просто отдаем
-- на выходе контейнер с примененной функцией f к элементу, лежащему внутри

-- фактически, fmap - это описание того, как применять передаваемую функцию к элементу/элементам, лежающим в контейнере,
-- то есть как пронести ее на уровень выше, чтобы построить контейнер, ведь хоть мы и передаем функцию, работующую
-- с базовыми типами, на самом деле мы хотим работать на уровне контейнеров
-- именно поэтому выше fmap для списков определили как map:
-- fmap f = map f - применение функции f к элементами, упакованным в контейнере (просто мы опустили там функцию в параметрах
--
-- можно теперь использовать fmap над контейнером Maybe:
-- fmap (*2) Nothing
--  -> Nothing
-- fmap (*2) (Just 5)
--  -> Just 10

--
-- типы, которые имеют больше одного параметра, можно делать представителям тайпкласса Functor следующим образом:
-- один из параметров связать сделать каким-то конкретным типом, тогда у нас станет на одну звездочку меньше (в kind типа)
-- и надо добиться того, чтобы стала ровно одна звездочка в kind
-- например:
-- :k Either Int b
--  -> Either Int :: * -> *
-- мы превратили тип с двумя параметрами в тип с 1 параметром, и теперь его можно делать представителем Functor
-- при этом значение первого типа изменяться не должно

--
-- например, для пары:
instance Functor ((,) s) where
  fmap g (x,y) = (x, g y)

-- здесь мы связываем первый параметр с типом s, а его менять нам нельзя:
-- так как тип fmap :: (a -> b) -> f a -> f b
-- здесь, а - это контейнер ((,) s)
-- тогда тип функции для пары становится таким:
-- (a -> b) -> ((,) s) a -> ((,) s) b
-- или что то же самое, просто в другом синтаксисе:
-- (a -> b) -> (s,a) -> (s,b)
-- первый элемент не меняется, поэтому мы применяем функцию f только ко второму элементу пары

-- также, для Either:
instance Functor (Either e) where
  fmap _ (Left x)  = Left x
  fmap g (Right y) = Right (g y)

-- мы связываем первый параметр с типом e, и тогда тип функции fmap для Either становится следующим:
-- (a -> b) -> Either e a -> Either e b
-- так как первый параметр - это тип значения, упакованного в конструктор данных Left:
-- data Either a b = Left a | Right b
-- то значение, упакованное в конструктор данных Left, не меняется
-- мы применяем функцию только к значению, упакованному в конструктор данных Right

-- попробуем применить какую-нибудь функцию над контейнером Either:
-- fmap (+1) (Left 5)
--  -> Left 5
-- fmap (*4) (Right 2)
--  -> Right 8

--
-- Какие законы должны соблюдаться, чтобы создать инстанс тайпкласса Functor:
-- 1. fmap id xs = id xs
-- Например:
-- fmap id [1,2,3] = [1,2,3]
-- применение функции f, здесь id, к элементу/элементам контейнера не должно менять значений, упакованных в контейнер
-- fmap id (Just a) = Just (f a)
-- для Maybe снова соблюдается этот закон
--
-- То есть, более строго: применение операции id к элементу/элементам, упакованных в контейнер, есть то же самое, что
-- и применение функции id к самому контейнеру, то есть после протаскивания функции id наверх на выходе мы получаем тот же
-- контейнер
-- 2. fmap (f . g) xs = (fmap f . fmap g) xs
-- данный закон говорит, что применение функции f к результату применения функции g над элементом контейнера есть то же самое,
-- что и сначала обработка всех значений функцией g, а потом обработка всех значений функцией f
-- Например:
-- fmap ((+1) . (^2)) [1,2,3]
--  -> [2,5,10]
-- fmap (+1) (fmap (^2) [1,2,3])
--  -> [2,5,10]
--
-- Соблюдение этих законов гарантирует то, что вызов fmap не меняет структуру контейнера, то есть функция, которая передается,
-- воздействует только на значения, упакованные в контейнер, но не воздействует на сам контейнер
--
-- Например, такая реализация инстанса тайпкласса Functor для списков не удовлетворяет законам:
instance Functor [] where
  fmap _ []     = []
  fmap f (x:xs) = f x : f x : fmap f xs

-- fmap id [1,2,3]
--  -> [1,1,2,2,3,3]
-- Структура контейнера изменилась! Но нашей задачей было только протаскивание функции f наверх, к элементам контейнера, но
-- никак не менять структуру контейнера
--
-- fmap ((+1) . (^2)) [1,2,3]
--  -> [2,2,5,5,10,10]
-- fmap (+1) (fmap (^2) [1,2,3])
--  -> [2,2,2,2,5,5,5,5,10,10,10,10]
-- второй закон тоже не соблюдается: первое выражение не эквивалентно второму
-- потому что в первом случае мы вызывали fmap только один раз, то есть только один раз удвоили список (ведь f x : f x удваивает
-- список), а во втором случае мы 2 раза вызвали fmap, и два раза удвоили список
