module Module_5_7 where

import           Data.Monoid

--
-- -----------------------
-- 5.7 Монада Writer
-- -----------------------
--

-- Монада Writer позволяет писать сообщения о проделанных действиях в лог

-- Монаду Writer можно реализовать как пару - (значение, лог)
-- Однако, можно сделать более обобощенный лог, а не только строковой - лог можно хранить Моноид
-- потому что у моноида есть операция свертки, которая на каждом шаге монодического вычисления позволяет в моноид что-то
-- добавить. Тогда можно использовать Моноид Sum или Product, в котором будет накапливаться сумма или произведение

-- первый параметр Writer - тип лога, в который будут писаться сообщения
-- a - тип значения, хранимого в контейнере

-- внутри конструктора данных лежит пара под названием runWriter, первым элементом которой является значение, а вторым - лог
newtype Writer w a = Writer {runWriter :: (a, w)} deriving Show

-- функция runWriter позволяет вынимать из Монады пару
--runWriter :: Writer w a -> (a, w)

-- на самом деле конструктор данных Writer устроен сильно сложнее, поэтому пользователю предоставляется функция для создания
-- контейнера writer, которая принимает пару и строит Монаду
writer :: (a, w) -> Writer w a
writer = Writer

-- для того чтобы достать только лог, так как иногда нас не интересует лежащее в Монаде значение, используется функция
-- execWriter. В цепочке вычислений
execWriter :: Writer w a -> w
execWriter m = snd (runWriter m)

instance (Monoid w) => Functor (Writer w)

instance (Monoid w) => Applicative (Writer w)

instance (Monoid w) => Monad (Writer w) where
-- здесь еще раз видна полезность Monoid - что написать в логе при упаковывании зачения? Тем более, так как тип лога
-- полиморфен, а не указан конкретный при создании, требуется использовать ждя каждого типа свое пустое значение
-- Monoid позвояет нам использовать пустое, нейтральное значение:
-- для строки - пустая строка, для Sum - 0, для Product - 1 и т.д.
  return x = Writer (x, mempty)
-- итак, что мы должны сделать в операторе (>>=):
-- 1. достать значение из Монады, обработать его Стрелкой Клейсли
-- 2. Осуществить запись в лог
  m >>= k =
    let (x, u) = runWriter m {-сначала достаем пару (значение, лог) из контейнера-}
        (y, v) = runWriter $ k x {-обрабатываем значение Стрелкой Клейсли и получаем новый контейнер, и достаем из
        контейнера пару для последующего построения конечного Writer-}
    in Writer (y, u `mappend` v) {-к старым сообщениям добавляем новые с помощью функции mappend и строим Writer-}
-- также, снова видна полезность Monoid - он позволяет сцепить значения
-- в случае строк - (++), Sum - (+), Product - (*)

-- попробуем построить Монаду Writer:
-- runWriter (return 3 :: Writer String Int)
--  -> (3,"")
-- runWriter (return 3 :: Writer (Sum Int) Int)
--  -> (3,Sum {getSum = 0})
-- runWriter (return 3 :: Writer (Product Int) Int)
--  -> (3,Product {getProduct = 1})

--
-- Монада Writer содержит ряд функций, которые позволяют работать с логом

-- данная функция принимает Моноид w и возвращает Writer с пустым значением, где в качестве лога записан Моноид w
-- то есть просто делается запись в лог
tell :: Monoid w => w -> Writer w ()
tell w = writer ((), w)

-- данная функция принимает бинарную операцию, операнды типа Int для применения данной операции,
-- а возвращает Writer с логом и значением, вычисленным с помощью переданной функции
-- также функция проверяет, не выходит ли результат применения операции за пределы 128,
-- если нет, то просто возвращается результат операции, упакованный в Writer с пустым логом
-- иначе, возвращается результат, также упакованный в Writer, но в логе будет находиться сообщение "overflow"
calc :: (Int -> Int -> Int) -> Int -> Int -> Writer String Int
calc op arg1 arg2 = do
  let res = arg1 `op` arg2
  if abs res < 128 then
    return res
  else do
    tell "overflow" {-здесь оператор (>>) позволяет добавить сообщения из вычисленной монады к следующему вычислению-}
-- да, оператор (>>) игнорирует ЗНАЧЕНИЕ предыдущего вычисления, но не игнорирует ЭФФЕКТ вычисления, что очень важно,
-- так как позволяет строить цепочки вычислений и производить какие-то действия с помощью вычислений Монад
-- ведь правда, что такой код e1 >> e2 >> e3 вычисляет монады и производит их эффект
-- в этом и смысл монадических вычислений
-- например,
-- runWriter $ tell "A" >> tell "B" >> tell "C"
--  -> ((),"ABC")
    return res

-- использование:
-- runWriter (calc (+) 127 2)
--  -> (129,"overflow")