module Module_5_6 where

--
-- -----------------------
-- 5.6 Монада Reader
-- -----------------------
--

-- Монада Reader позволяет во время монадичных вычислений обращаться к какому-то константному окружению и считывать оттуда
-- какое-то значение (Environment monad)

-- тип этой монады - ((->) e)

--instance Functor ((->) e) where
--fmap :: (a -> b) -> f a -> f b
--fmap :: (a -> b) -> ((->) e) a -> ((->) e) b
--fmap :: (a -> b) -> (->) e a -> ((->) e) b
--fmap :: (a -> b) -> (e -> a) -> (e -> b)
-- идея такова: мы можем окружение прицепить к какой-то функции (a -> b), обрабатывающей значение контейнера
--  fmap g h = g . h

-- например, использование:
-- fmap (^2) length
-- здесь, аргумент функции length описывает наше окружение, так как length - как раз передааваемый 2 параметр (e -> a),
-- и параметр этой функции - список, значит e - это список
-- теперь мы можем работать с значением, но в контексте списка
-- то есть мы все также обрабатывает какое-то значение, но как и говорилось, Reader позволяет доставать значение из какого-то
-- окружения

-- сравним: fmap (^2) [1,2,3] <- здесь мы работает в монаде списка
--  -> [1,4,9]
-- fmap (^2) length [1,2,3] <- здесь мы работает в монаде Reader, т.е. вычисление в окружении
--  -> 9

-- монада Reader позволяет строить цепочку вычислений внутри определенного окружения

{-
instance Monad ((->) e) where
  return :: a -> m a
  return : a -> e -> a <- как мы видим, монада принимает какое-то значение a, и возвращает это же значение, упакованное в
-- окружение. Но, т.к. e - это не контейнер какой-то, а просто окружение, и мы должны его принять, то после принятия значения
-- и окружения, return просто возвращает a:
  return x = \_ -> x
  (>>=) :: m a -> (a -> m b) -> m b
  (>>=) :: (e -> a) -> (a -> e -> b) -> e -> b
  m >>= k = \e -> k (m e) e
-- разберем, что делает эта функция
-- во первых, дополнительным параметром у нее принимается окружение, а дальше, с помощью пераднной функции k типа
-- (a -> e -> b) мы работаем с этим значением внутри окружения, а само значение достается с помощью Монады Reader m
-- типа (e -> a)
-- вот тут мы и видим, что происходит:
-- первый параметр m - это монада Reader, которая читает из окружения какое-то значение: e -> a
-- второй параметр k - стрелка Клейсли, которая работает с этим значением, и снова упаковывает его в монаду Reader
-- работа, проделанная над значением из окружения, упаковывается снова в монаду Reader, которая будет хранить уже
-- новое значение, но все еще принимающая окружение e: e -> b
-- заметим, что применение функции Клейсли к читаемому значению a (т.е. (m e)) и окружению e дает нам тип b:
-- действительно (a -> e -> b), здесь a - это (m e), e - это окружение e, но ведь нам надо вернуть контейнер?
-- дело в том, что из-за лямбда функции , где принимается \e, и появляется e, то есть, мы как бы обработали значениеи из
-- окружения, но оно все еще будет находиться внутри окружения, так как эта функция возвращает монаду, которая принимает
-- окружение. И при последующем использовании этой монады, мы уже сможем считать значение из нее, уже обработанное
-}

-- использование:
-- мы можем писать обычные функции без упаковывания их в контейнер, так как мы работает в окружении списка
-- и все функции будут неявно применять к списку
safeHead = do
  b <- null {-проверяем окружение на пустоту-}
  if b
  then return Nothing {-упаковывать Nothing в монаду нужно потому, что мы работаем в монаде Reader-}
  else do
    h <- head
    return $ Just h {-снова упаковываем значение в монаду Reader-}

-- ключевой момент здесь - упаковывание конечных значений
-- выше мы говорили, что в итоге возвращается функция, которая принимает окружение, и возвращает какое-то значение
-- здесь, принимаемое окружение - это список
-- это можно увидеть по типу функции safeHead:
-- :t safeHead
--  -> safeHead :: [a] -> Maybe a
-- в итоге, теперь все функции внутри монады работают с этим окружением [a]
-- так как все операторы (>>=) будут работать так: m >>= k = \e -> k (m e) e
-- то, например, самая первая инструкция b < null транслируется в следующее:
-- null >>= (\b -> ...)
-- \e -> (\b -> (\e -> ...)) (null e) e
-- мы видим, что список каждый раз неявно передается в каждую следующую инструкцию, и в каждой функции он неявно применяется
-- так как каждый следующий оператор (>>=) еще раз генерирует лямбду начинающуюся с принятия окружения (\e -> ...)
--

-- оператор (>>) в цепочке вычислений в монаде Reader абсолютно бесполезен:
-- в то время как оператор (>>=) позволяет передать одно и то же значение (окружение) в качестве аргумента нескольким функциям
-- в цепочке композиций
-- оператор (>>) игнорирует результат работы прошлого степа, и везде вместо \e будет \_