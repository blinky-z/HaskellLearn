module Module_5_2 where


--
-- -----------------------
-- 5.2 Определение монады
-- -----------------------
--

-- Монады позволяют наложить на вычисление определенный эффект

--f :: a -> m b
-- Примеры:
--f :: a -> Maybe b            -- m = Maybe
--f :: a -> [] b               -- m = []
--f :: a -> (Either s) b       -- m = Either s
--f :: a -> ((,) s) b          -- m = ((,) s)
--f :: a -> ((->) e) b         -- m = ((->) e)
--f :: a -> (State s) b        -- m = State s
--f :: a -> IO b               -- m = IO

-- Обобщение этого - Стрелка Клейсли:
-- она берет значение и упаковывает его в контейнер m
-- a -> m b

-- Тайпкласс Monad можно определить так:
{-
class Monad m where
  return :: a -> m a <- упаковывает значение a в контейнер m, стрелка Клейсли
  (>>=) :: m a -> (a -> m b) -> m b
  ...

infixl 1 >>=
-}

-- m должен быть однопараметрическим конструктором типов

-- использование::
-- return True :: [] Bool
--  -> [True]
-- почему надо использовать так, можно понять из типа return:
-- :t return True
--  -> return True :: Monad m => m Bool
-- мы видим, что конструктор данных контейнера m полиморфен:
-- хоть внутри контейнера и лежит значение True, но так как оно может быть упаковано в любой однопараметрический конструктор
-- данных, то следует вызывать return True на определенном конструкторе данных контейнера
--
-- еще один пример использования:
-- return True :: Maybe Bool
--  -> Just True
-- итак, мы должны указывать целевой тип, потому что результат упаковывания в контейнер полиморфен

-- разберем теперь оператор (>>=) - называется bind
-- оператор (>>=) принимает первым параметром значение типа a, упакованное в монодический контейнер m
-- вторым параметром принимает стрелку Клейсли из типа a в m b
-- и возвращает нам значение типа b, упакованное в тот же монодический контейнер m
-- идея оператор bind такая: он должен взять из монады значение типа a, и передать его в стрелку Клейсли, получив значение типа
-- (m b) и вернуть это значение пользователю

-- то есть отличие вот в чем, обычно return берет значение и упаковывает его в монаду, добавляя допольнительный контекст
-- а оператор (>>=) должен достать на основе уже существующего контекста и данных, упакованных в контейнер,
-- обработать значение в контейнере и вернуть новый контейнер, при этом сохраняя или нет контекст, зависит уже от реализации
-- программиста инстанса Monad для конкретного типа

-- вообще, все Монады - это Functor
-- ведь они правда проносят значение наверх и упаковывают его в контейнер
-- различие в том, что Монада может изменять контейнер, а Функтор не может
--
-- в хаскеле все инстансы монады должно иметь инстанс Функтора, благодаря этому мы можем изменять значение внутри контейнера
-- например, оператор (>>=) требует стрелку Клейсли, но если мы не знаем конструктора данных монады, то можем использовать fmap
-- для построения такой функции
-- в классе Monad есть еще функции, которые имеют реализацию по умолчанию:
--
-- 1. оператор (>>)
-- (>>) :: m a -> m b -> m b
-- данная функция отличается от оператор (>>=) тем, что она не изменяет значения первоначального элемента
-- реализация оператора (>>):
-- x >> y = x >>= (\_ -> y)
-- он реализован через оператор (>>=), но в качестве функции, которая обрабатывает элемент, упакованный в контейнер m a,
-- данный оператор передает функцию (\_ -> y), то есть новый контейнер возвращается, но любое передаваемое туда значение
-- будет игнорироваться
--
-- 2. функция fail
-- fail :: String -> m a
-- fail s = error s
-- функция fail вызывается автоматически, когда дальнейшие вычисления не могут продолжаться
-- так как функция error может возвращать полиморфное значение: error :: [Char] -> a
-- то мы можем сделать возвращаемым типом (m a)
-- 3. оператор (=<<)
-- (=<<) = flip (>>=)
-- данный оператор позволяет развернуть цепочку вычислений в обратную сторону
-- все вычисления обычно производятся начиная слева